(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{857:function(t,e,o){"use strict";o.r(e);var v=o(58),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h3",{attrs:{id:"tomcat-是什么？"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tomcat-是什么？"}},[t._v("#")]),t._v(" Tomcat 是什么？")]),t._v(" "),o("p",[t._v("Tomcat 服务器 Apache 软件基金会项目中的一个核心项目，是一个免费的开放源代码的 Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试 JSP 程序的首选。")]),t._v(" "),o("h3",{attrs:{id:"tomcat-的缺省端口是多少，怎么修改"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tomcat-的缺省端口是多少，怎么修改"}},[t._v("#")]),t._v(" Tomcat 的缺省端口是多少，怎么修改")]),t._v(" "),o("p",[t._v("找到 Tomcat 目录下的 conf 文件夹")]),t._v(" "),o("p",[t._v("进入 conf 文件夹里面找到 server.xml 文件")]),t._v(" "),o("p",[t._v("打开 server.xml 文件")]),t._v(" "),o("p",[t._v("在 server.xml 文件里面找到下列信息")]),t._v(" "),o("p",[t._v("把 Connector 标签的 8080 端口改成你想要的端口")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v('<Service name="Catalina"><Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" />\n\n')])])]),o("h3",{attrs:{id:"tomcat-有哪几种-connector-运行模式-优化-？"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tomcat-有哪几种-connector-运行模式-优化-？"}},[t._v("#")]),t._v(" tomcat 有哪几种 Connector 运行模式(优化)？")]),t._v(" "),o("p",[t._v("下面，我们先大致了解 Tomcat Connector 的三种运行模式。")]),t._v(" "),o("ul",[o("li",[t._v("BIO：同步并阻塞 一个线程处理一个请求。缺点：并发量高时，线程数较多，浪费资源。Tomcat7 或以下，在 Linux 系统中默认使用这种方式。")])]),t._v(" "),o("p",[t._v("配制项：protocol=”HTTP/1.1”")]),t._v(" "),o("ul",[o("li",[t._v("NIO：同步非阻塞 IO")])]),t._v(" "),o("p",[t._v("利用 Java 的异步 IO 处理，可以通过少量的线程处理大量的请求，可以复用同一个线程处理多个 connection(多路复用)。")]),t._v(" "),o("p",[t._v("Tomcat8 在 Linux 系统中默认使用这种方式。")]),t._v(" "),o("p",[t._v("Tomcat7 必须修改 Connector 配置来启动。")]),t._v(" "),o("p",[t._v("配制项：protocol=”org.apache.coyote.http11.Http11NioProtocol”")]),t._v(" "),o("p",[t._v("备注：我们常用的 Jetty，Mina，ZooKeeper 等都是基于 java nio 实现.")]),t._v(" "),o("ul",[o("li",[t._v("APR：即 Apache Portable Runtime，从操作系统层面解决 io 阻塞问题。异步非阻塞 IO(Java NIO2 又叫 AIO) 主要与 NIO 的区别主要是操作系统的底层区别.可以做个比喻:比作快递，NIO 就是网购后要自己到官网查下快递是否已经到了(可能是多次)，然后自己去取快递；AIO 就是快递员送货上门了(不用关注快递进度)。")])]),t._v(" "),o("p",[t._v("配制项：protocol=”org.apache.coyote.http11.Http11AprProtocol”")]),t._v(" "),o("p",[t._v("备注：需在本地服务器安装 APR 库。Tomcat7 或 Tomcat8 在 Win7 或以上的系统中启动默认使用这种方式。Linux 如果安装了 apr 和 native，Tomcat 直接启动就支持 apr。")]),t._v(" "),o("h3",{attrs:{id:"tomcat-有几种部署方式？"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tomcat-有几种部署方式？"}},[t._v("#")]),t._v(" Tomcat 有几种部署方式？")]),t._v(" "),o("p",[t._v("在 Tomcat 中部署 Web 应用的方式主要有如下几种：")]),t._v(" "),o("ul",[o("li",[t._v("利用 Tomcat 的自动部署。")])]),t._v(" "),o("p",[t._v("把 web 应用拷贝到 webapps 目录。Tomcat 在启动时会加载目录下的应用，并将编译后的结果放入 work 目录下。")]),t._v(" "),o("ul",[o("li",[t._v("使用 Manager App 控制台部署。")])]),t._v(" "),o("p",[t._v("在 tomcat 主页点击“Manager App” 进入应用管理控制台，可以指定一个 web 应用的路径或 war 文件。")]),t._v(" "),o("ul",[o("li",[t._v("修改 conf/server.xml 文件部署。")])]),t._v(" "),o("p",[t._v("修改 conf/server.xml 文件，增加 Context 节点可以部署应用。")]),t._v(" "),o("ul",[o("li",[t._v("增加自定义的 Web 部署文件。")])]),t._v(" "),o("p",[t._v("在 conf/Catalina/localhost/ 路径下增加 xyz.xml 文件，内容是 Context 节点，可以部署应用。")]),t._v(" "),o("h3",{attrs:{id:"tomcat-容器是如何创建-servlet-类实例？用到了什么原理？"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tomcat-容器是如何创建-servlet-类实例？用到了什么原理？"}},[t._v("#")]),t._v(" tomcat 容器是如何创建 servlet 类实例？用到了什么原理？")]),t._v(" "),o("p",[t._v("当容器启动时，会读取在 webapps 目录下所有的 web 应用中的 web.xml 文件，然后对 xml 文件进行解析，并读取 servlet 注册信息。然后，将每个应用中注册的 servlet 类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化）")]),t._v(" "),o("p",[t._v("在 servlet 注册时加上 1 如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。")]),t._v(" "),o("h3",{attrs:{id:"tomcat-工作模式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tomcat-工作模式"}},[t._v("#")]),t._v(" Tomcat 工作模式")]),t._v(" "),o("p",[t._v("Tomcat 作为 servlet 容器，有三种工作模式：")]),t._v(" "),o("p",[t._v("1、独立的 servlet 容器，servlet 容器是 web 服务器的一部分；")]),t._v(" "),o("p",[t._v("2、进程内的 servlet 容器，servlet 容器是作为 web 服务器的插件和 java 容器的实现，web 服务器插件在内部地址空间打开一个 jvm 使得 java 容器在内部得以运行。反应速度快但伸缩性不足；")]),t._v(" "),o("p",[t._v("3、进程外的 servlet 容器，servlet 容器运行于 web 服务器之外的地址空间，并作为 web 服务器的插件和 java 容器实现的结合。反应时间不如进程内但伸缩性和稳定性比进程内优；")]),t._v(" "),o("p",[t._v("进入 Tomcat 的请求可以根据 Tomcat 的工作模式分为如下两类：")]),t._v(" "),o("p",[t._v("Tomcat 作为应用程序服务器：请求来自于前端的 web 服务器，这可能是 Apache, IIS, Nginx 等；")]),t._v(" "),o("p",[t._v("Tomcat 作为独立服务器：请求来自于 web 浏览器；")]),t._v(" "),o("p",[t._v("面试时问到 Tomcat 相关问题的几率并不高，正式因为如此，很多人忽略了对 Tomcat 相关技能的掌握，下面这一篇文章整理了 Tomcat 相关的系统架构，介绍了 Server、Service、Connector、Container 之间的关系，各个模块的功能，可以说把这几个掌握住了，Tomcat 相关的面试题你就不会有任何问题了！另外，在面试的时候你还要有意识无意识的往 Tomcat 这个地方引，就比如说常见的 Spring MVC 的执行流程，一个 URL 的完整调用链路，这些相关的题目你是可以往 Tomcat 处理请求的这个过程去说的！掌握了 Tomcat 这些技能，面试官一定会佩服你的！")]),t._v(" "),o("p",[t._v("学了本章之后你应该明白的是：")]),t._v(" "),o("p",[t._v("Server、Service、Connector、Container 四大组件之间的关系和联系，以及他们的主要功能点；")]),t._v(" "),o("p",[t._v("Tomcat 执行的整体架构，请求是如何被一步步处理的；")]),t._v(" "),o("p",[t._v("Engine、Host、Context、Wrapper 相关的概念关系；")]),t._v(" "),o("p",[t._v("Container 是如何处理请求的；")]),t._v(" "),o("p",[t._v("Tomcat 用到的相关设计模式；")]),t._v(" "),o("h3",{attrs:{id:"tomcat-顶层架构"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tomcat-顶层架构"}},[t._v("#")]),t._v(" Tomcat 顶层架构")]),t._v(" "),o("p",[t._v("俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，Tomcat 的结构很复杂，但是 Tomcat 非常的模块化，找到了 Tomcat 最核心的模块，问题才可以游刃而解，了解了 Tomcat 的整体架构对以后深入了解 Tomcat 来说至关重要！")]),t._v(" "),o("p",[t._v("先上一张 Tomcat 的顶层结构图（图 A），如下："),o("br"),t._v(" "),o("img",{attrs:{src:"/assets/img/tomcat/image2020-4-9_15-3-13.png",alt:"alt text",title:"Tomcat的顶层结构图"}})]),t._v(" "),o("p",[t._v("Tomcat 中最顶层的容器是 Server，代表着整个服务器，从上图中可以看出，一个 Server 可以包含至少一个 Service，即可以包含多个 Service，用于具体提供服务。")]),t._v(" "),o("p",[t._v("Service 主要包含两个部分：Connector 和 Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：")]),t._v(" "),o("p",[t._v("Connector 用于处理连接相关的事情，并提供 Socket 与 Request 请求和 Response 响应相关的转化;")]),t._v(" "),o("p",[t._v("Container 用于封装和管理 Servlet，以及具体处理 Request 请求；")]),t._v(" "),o("p",[t._v("一个 Tomcat 中只有一个 Server，一个 Server 可以包含多个 Service，一个 Service 只有一个 Container，但是可以有多个 Connectors，这是因为一个服务可以有多个连接，如同时提供 Http 和 Https 链接，也可以提供向相同协议不同端口的连接，示意图如下（Engine、Host、Context 下面会说到）：")]),t._v(" "),o("p",[t._v("多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。")]),t._v(" "),o("p",[t._v("另外，上述的包含关系或者说是父子关系，都可以在 tomcat 的 conf 目录下的 server.xml 配置文件中看出，下图是删除了注释内容之后的一个完整的 server.xml 配置文件（Tomcat 版本为 8.0）")]),t._v(" "),o("p",[t._v("详细的配置文件内容可以到 Tomcat 官网查看：")]),t._v(" "),o("p",[t._v("http://tomcat.apache.org/tomcat-8.0-doc/index.html")]),t._v(" "),o("p",[t._v("上边的配置文件，还可以通过下边的一张结构图更清楚的理解：")]),t._v(" "),o("p",[t._v("Server 标签设置的端口号为 8005，shutdown=”SHUTDOWN” ，表示在 8005 端口监听“SHUTDOWN”命令，如果接收到了就会关闭 Tomcat。一个 Server 有一个 Service，当然还可以进行配置，一个 Service 有多个 Connector，Service 左边的内容都属于 Container 的，Service 下边是 Connector。")]),t._v(" "),o("h3",{attrs:{id:"tomcat-顶层架构小结"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tomcat-顶层架构小结"}},[t._v("#")]),t._v(" Tomcat 顶层架构小结")]),t._v(" "),o("p",[t._v("Tomcat 中只有一个 Server，一个 Server 可以有多个 Service，一个 Service 可以有多个 Connector 和一个 Container；")]),t._v(" "),o("p",[t._v("Server 掌管着整个 Tomcat 的生死大权；")]),t._v(" "),o("p",[t._v("Service 是对外提供服务的；")]),t._v(" "),o("p",[t._v("Connector 用于接受请求并将请求封装成 Request 和 Response 来具体处理；")]),t._v(" "),o("p",[t._v("Container 用于封装和管理 Servlet，以及具体处理 request 请求；")]),t._v(" "),o("p",[t._v("知道了整个 Tomcat 顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说 Server 和 Service 对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于 Connector 和 Container 的，所以接下来介绍一下 Connector 和 Container。")]),t._v(" "),o("h3",{attrs:{id:"connector-和-container-的微妙关系"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#connector-和-container-的微妙关系"}},[t._v("#")]),t._v(" Connector 和 Container 的微妙关系")]),t._v(" "),o("p",[t._v("由上述内容我们大致可以知道一个请求发送到 Tomcat 之后，首先经过 Service 然后会交给我们的 Connector，Connector 用于接收请求并将接收的请求封装为 Request 和 Response 来具体处理，Request 和 Response 封装完之后再交由 Container 进行处理，Container 处理完请求之后再返回给 Connector，最后在由 Connector 通过 Socket 将处理的结果返回给客户端，这样整个请求的就处理完了！")]),t._v(" "),o("p",[t._v("Connector 最底层使用的是 Socket 来进行连接的，Request 和 Response 是按照 HTTP 协议来封装的，所以 Connector 同时需要实现 TCP/IP 协议和 HTTP 协议！")]),t._v(" "),o("p",[t._v("Tomcat 既然需要处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下 Connector！")]),t._v(" "),o("h3",{attrs:{id:"connector-架构分析"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#connector-架构分析"}},[t._v("#")]),t._v(" Connector 架构分析")]),t._v(" "),o("p",[t._v("Connector 用于接受请求并将请求封装成 Request 和 Response，然后交给 Container 进行处理，Container 处理完之后在交给 Connector 返回给客户端。")]),t._v(" "),o("p",[t._v("因此，我们可以把 Connector 分为四个方面进行理解：")]),t._v(" "),o("p",[t._v("Connector 如何接受请求的？")]),t._v(" "),o("p",[t._v("如何将请求封装成 Request 和 Response 的？")]),t._v(" "),o("p",[t._v("封装完之后的 Request 和 Response 如何交给 Container 进行处理的？")]),t._v(" "),o("p",[t._v("Container 处理完之后如何交给 Connector 并返回给客户端的？")]),t._v(" "),o("p",[t._v("首先看一下 Connector 的结构图（图 B），如下所示：")]),t._v(" "),o("p",[t._v("Connector 就是使用 ProtocolHandler 来处理请求的，不同的 ProtocolHandler 代表不同的连接类型，比如：Http11Protocol 使用的是普通 Socket 来连接的，Http11NioProtocol 使用的是 NioSocket 来连接的。")]),t._v(" "),o("p",[t._v("其中 ProtocolHandler 由包含了三个部件：Endpoint、Processor、Adapter。")]),t._v(" "),o("p",[t._v("Endpoint 用来处理底层 Socket 的网络连接，Processor 用于将 Endpoint 接收到的 Socket 封装成 Request，Adapter 用于将 Request 交给 Container 进行具体的处理。")]),t._v(" "),o("p",[t._v("Endpoint 由于是处理底层的 Socket 网络连接，因此 Endpoint 是用来实现 TCP/IP 协议的，而 Processor 用来实现 HTTP 协议的，Adapter 将请求适配到 Servlet 容器进行具体的处理。")]),t._v(" "),o("p",[t._v("Endpoint 的抽象实现 AbstractEndpoint 里面定义的 Acceptor 和 AsyncTimeout 两个内部类和一个 Handler 接口。Acceptor 用于监听请求，AsyncTimeout 用于检查异步 Request 的超时，Handler 用于处理接收到的 Socket，在内部调用 Processor 进行处理。")]),t._v(" "),o("p",[t._v("至此，我们应该很轻松的回答 1，2，3 的问题了，但是 4 还是不知道，那么我们就来看一下 Container 是如何进行处理的以及处理完之后是如何将处理完的结果返回给 Connector 的？")]),t._v(" "),o("p",[t._v("Container 架构分析\nContainer 用于封装和管理 Servlet，以及具体处理 Request 请求，在 Container 内部包含了 4 个子容器，结构图如下（图 C）：")]),t._v(" "),o("p",[t._v("4 个子容器的作用分别是：")]),t._v(" "),o("p",[t._v("Engine：引擎，用来管理多个站点，一个 Service 最多只能有一个 Engine；")]),t._v(" "),o("p",[t._v("Host：代表一个站点，也可以叫虚拟主机，通过配置 Host 就可以添加站点；")]),t._v(" "),o("p",[t._v("Context：代表一个应用程序，对应着平时开发的一套程序，或者一个 WEB-INF 目录以及下面的 web.xml 文件；")]),t._v(" "),o("p",[t._v("Wrapper：每一 Wrapper 封装着一个 Servlet；")]),t._v(" "),o("p",[t._v("下面找一个 Tomcat 的文件目录对照一下，如下图所示：")]),t._v(" "),o("p",[t._v("Context 和 Host 的区别是 Context 表示一个应用，我们的 Tomcat 中默认的配置下 webapps 下的每一个文件夹目录都是一个 Context，其中 ROOT 目录中存放着主应用，其他目录存放着子应用，而整个 webapps 就是一个 Host 站点。")]),t._v(" "),o("p",[t._v("我们访问应用 Context 的时候，如果是 ROOT 下的则直接使用域名就可以访问，例如：www.baidu.com，如果是 Host（webapps）下的其他应用，则可以使用 www.baidu.com/docs 进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过 Host 站点下默认的主应用是 ROOT 目录下的。")])])}),[],!1,null,null,null);e.default=r.exports}}]);